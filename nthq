[1mdiff --git a/main.py b/main.py[m
[1mindex 4061367..c31d547 100644[m
[1m--- a/main.py[m
[1m+++ b/main.py[m
[36m@@ -8,6 +8,7 @@[m [mimport numpy as np[m
 import sys[m
 from vertex_math import *[m
 from matrix import *[m
[32m+[m[32mimport glm[m
 program = None[m
 vbo, nvbo, cvbo = None, None, None[m
 window = None[m
[36m@@ -20,11 +21,59 @@[m [mframecount = 0[m
 inputs = {'mouse': [0, 0]}  # this is probably bad[m
 [m
 vertex_pos = np.array([m
[31m-    [0.75, 0.75, 0.0,[m
[31m-     0.75, -0.75, 0.0,[m
[31m-     -0.75, -0.75, 0.0],[m
[32m+[m[32m    # [0.75, 0.75, 0.0,[m
[32m+[m[32m    #  0.75, -0.75, 0.0,[m
[32m+[m[32m    #  -0.75, -0.75, 0.0],[m
[32m+[m[32m    [-1.0, -1.0, -1.0,[m
[32m+[m[32m     -1.0, -1.0, 1.0,[m
[32m+[m[32m     -1.0, 1.0, 1.0,[m
[32m+[m[32m     1.0, 1.0, -1.0,[m
[32m+[m[32m     -1.0, -1.0, -1.0,[m
[32m+[m[32m     -1.0, 1.0, -1.0,[m
[32m+[m[32m     1.0, -1.0, 1.0,[m
[32m+[m[32m     -1.0, -1.0, -1.0,[m
[32m+[m[32m     1.0, -1.0, -1.0,[m
[32m+[m[32m     1.0, 1.0, -1.0,[m
[32m+[m[32m     1.0, -1.0, -1.0,[m
[32m+[m[32m     -1.0, -1.0, -1.0,[m
[32m+[m[32m     -1.0, -1.0, -1.0,[m
[32m+[m[32m     -1.0, 1.0, 1.0,[m
[32m+[m[32m     -1.0, 1.0, -1.0,[m
[32m+[m[32m     1.0, -1.0, 1.0,[m
[32m+[m[32m     -1.0, -1.0, 1.0,[m
[32m+[m[32m     -1.0, -1.0, -1.0,[m
[32m+[m[32m     -1.0, 1.0, 1.0,[m
[32m+[m[32m     -1.0, -1.0, 1.0,[m
[32m+[m[32m     1.0, -1.0, 1.0,[m
[32m+[m[32m     1.0, 1.0, 1.0,[m
[32m+[m[32m     1.0, -1.0, -1.0,[m
[32m+[m[32m     1.0, 1.0, -1.0,[m
[32m+[m[32m     1.0, -1.0, -1.0,[m
[32m+[m[32m     1.0, 1.0, 1.0,[m
[32m+[m[32m     1.0, -1.0, 1.0,[m
[32m+[m[32m     1.0, 1.0, 1.0,[m
[32m+[m[32m     1.0, 1.0, -1.0,[m
[32m+[m[32m     -1.0, 1.0, -1.0,[m
[32m+[m[32m     1.0, 1.0, 1.0,[m
[32m+[m[32m     -1.0, 1.0, -1.0,[m
[32m+[m[32m     -1.0, 1.0, 1.0,[m
[32m+[m[32m     1.0, 1.0, 1.0,[m
[32m+[m[32m     -1.0, 1.0, 1.0,[m
[32m+[m[32m     1.0, -1.0, 1.0],[m
     dtype='float32'[m
 )[m
[32m+[m[32mnum_points = 100[m
[32m+[m[32mfor i in range(num_points):[m
[32m+[m[32m    vertex_pos = np.append(vertex_pos, np.array([[m
[32m+[m[32m        np.sin(i/num_points * 2 * np.pi),[m
[32m+[m[32m        np.cos(i/num_points * 2 * np.pi),[m
[32m+[m[32m        0,[m
[32m+[m[32m        np.sin((i+1) / num_points * 2 * np.pi),[m
[32m+[m[32m        np.cos((i+1) / num_points * 2 * np.pi),[m
[32m+[m[32m        0,[m
[32m+[m[32m        0, 0, 0[m
[32m+[m[32m    ], dtype='float32')[m
[32m+[m[32m    )[m
 color = np.array([m
     [0.583,  0.771,  0.014,[m
     0.609,  0.115,  0.436,[m
[36m@@ -61,12 +110,53 @@[m [mcolor = np.array([m
     0.393,  0.621,  0.362,[m
     0.673,  0.211,  0.457,[m
     0.820,  0.883,  0.371,[m
[31m-    0.982,  0.099,  0.879],[m
[32m+[m[32m    0.982,  0.099,  0.879,[m
[32m+[m
[32m+[m[32m    0.583,  0.771,  0.014,[m
[32m+[m[32m    0.609,  0.115,  0.436,[m
[32m+[m[32m    0.327,  0.483,  0.844,[m
[32m+[m[32m    0.822,  0.569,  0.201,[m
[32m+[m[32m    0.435,  0.602,  0.223,[m
[32m+[m[32m    0.310,  0.747,  0.185,[m
[32m+[m[32m    0.597,  0.770,  0.761,[m
[32m+[m[32m    0.559,  0.436,  0.730,[m
[32m+[m[32m    0.359,  0.583,  0.152,[m
[32m+[m[32m    0.483,  0.596,  0.789,[m
[32m+[m[32m    0.559,  0.861,  0.639,[m
[32m+[m[32m    0.195,  0.548,  0.859,[m
[32m+[m[32m    0.014,  0.184,  0.576,[m
[32m+[m[32m    0.771,  0.328,  0.970,[m
[32m+[m[32m    0.406,  0.615,  0.116,[m
[32m+[m[32m    0.676,  0.977,  0.133,[m
[32m+[m[32m    0.971,  0.572,  0.833,[m
[32m+[m[32m    0.140,  0.616,  0.489,[m
[32m+[m[32m    0.997,  0.513,  0.064,[m
[32m+[m[32m    0.945,  0.719,  0.592,[m
[32m+[m[32m    0.543,  0.021,  0.978,[m
[32m+[m[32m    0.279,  0.317,  0.505,[m
[32m+[m[32m    0.167,  0.620,  0.077,[m
[32m+[m[32m    0.347,  0.857,  0.137,[m
[32m+[m[32m    0.055,  0.953,  0.042,[m
[32m+[m[32m    0.714,  0.505,  0.345,[m
[32m+[m[32m    0.783,  0.290,  0.734,[m
[32m+[m[32m    0.722,  0.645,  0.174,[m
[32m+[m[32m    0.302,  0.455,  0.848,[m
[32m+[m[32m    0.225,  0.587,  0.040,[m
[32m+[m[32m    0.517,  0.713,  0.338,[m
[32m+[m[32m    0.053,  0.959,  0.120,[m
[32m+[m[32m    0.393,  0.621,  0.362,[m
[32m+[m[32m    0.673,  0.211,  0.457,[m
[32m+[m[32m    0.820,  0.883,  0.371,[m
[32m+[m[32m    0.982,  0.099,  0.879[m
[32m+[m[32m     ],[m
     dtype='float32'[m
 )[m
[32m+[m[32mwhile len(color) < len(vertex_pos):[m
[32m+[m[32m    color = np.append(color, np.array([1], dtype='float32'))[m
 normals = get_normals(vertex_pos)[m
[31m-[m
[31m-[m
[32m+[m[32m# normals = np.array([])[m
[32m+[m[32m# while len(normals) < len(vertex_pos):[m
[32m+[m[32m#     normals = np.append(normals, np.array([1]))[m
 [m
 def create_window(size, pos, title):[m
     glutInitWindowSize(size[0], size[1])[m
[36m@@ -82,11 +172,21 @@[m [mdef render():[m
     glUseProgram(program)[m
 [m
     projection_mat = create_projection_matrix(45.0, 4 / 3, 0.1, 100)[m
[31m-    fcfact = np.sin(framecount*np.pi/180)[m
[31m-    view_mat = look_at(np.array([4, 4, 0+5*fcfact], dtype='float32'), np.array([0, 0, 0], dtype='float32'),[m
[31m-                       np.array([0, -1, 0], dtype='float32'))[m
[32m+[m[32m    obj_translation = np.array([0, 0, 0], dtype='float32') # np.array([np.cos(framecount * 0.0005), 0.0, np.sin(framecount * 0.0005)], dtype='float32') * 1.0[m
[32m+[m[32m    # cam = np.array([np.sin(framecount * 0.0001), 0, np.cos(framecount * 0.0001)], dtype='float32')[m
[32m+[m[32m    # cam = np.array([-1, -1, np.sin(framecount * 0.0001)], dtype='float32')[m
[32m+[m[32m    mouse = np.array([inputs['mouse'][0]/800-0.5, inputs['mouse'][1]/600-0.5], dtype='float32')[m
[32m+[m[32m    cam = np.array([0, np.sin(mouse[0] * 3), np.cos(mouse[1] * 3)], dtype='float32')[m
[32m+[m[32m    up = np.array([0, 1, 0], dtype='float32')[m
[32m+[m[32m    # view_mat = look_at(np.array([4, 4, 0+5*fcfact], dtype='float32'), np.array([0, 0, 0], dtype='float32'),[m
[32m+[m[32m    #                    np.array([0, -1, 0], dtype='float32'))[m
[32m+[m[32m    # view_mat = look_at(cam, obj_translation, up)[m
[32m+[m[32m    view_mat = glm.lookAt(glm.vec3())[m
[32m+[m[32m    # view_mat = np.identity(4, dtype='float32')[m
     model_mat = np.identity(4, dtype='float32')[m
[31m-    MVP_mat = np.identity(4) * view_mat * model_mat[m
[32m+[m[32m    # model_mat = create_translation_matrix(-obj_translation)[m
[32m+[m[32m    projection_mat = np.identity(4, dtype='float32')[m
[32m+[m[32m    MVP_mat = projection_mat * view_mat * model_mat[m
 [m
     glUniformMatrix4fv(mvpLoc, 1, GL_FALSE, MVP_mat.transpose())[m
 [m
[36m@@ -99,13 +199,13 @@[m [mdef render():[m
 [m
     glEnableVertexAttribArray(1)[m
     nvbo.bind()[m
[31m-    glVertexAttribPointer(1, 3, GL_FLOAT, GL_TRUE, 0, None)[m
[32m+[m[32m    glVertexAttribPointer(1, 1, GL_FLOAT, GL_TRUE, 0, None)[m
 [m
     glEnableVertexAttribArray(2)[m
     cvbo.bind()[m
     glVertexAttribPointer(2, 3, GL_FLOAT, GL_TRUE, 0, None)[m
 [m
[31m-    glDrawArrays(GL_TRIANGLES, 0, 3)[m
[32m+[m[32m    glDrawArrays(GL_TRIANGLES, 0, len(vertex_pos) * 3)[m
     glDisableVertexAttribArray(0)[m
     glDisableVertexAttribArray(1)[m
     glDisableVertexAttribArray(2)[m
[1mdiff --git a/matrix.py b/matrix.py[m
[1mindex a0c0c07..655f838 100644[m
[1m--- a/matrix.py[m
[1m+++ b/matrix.py[m
[36m@@ -1,3 +1,4 @@[m
[32m+[m[32mimport glm[m
 import numpy as np[m
 import vertex_math[m
 [m
[36m@@ -10,6 +11,7 @@[m [mdef create_projection_matrix(fov, aspect_ratio, near_clip, far_clip):[m
     arr[2][2] = (far_clip + near_clip) / (near_clip - far_clip)[m
     arr[2][3] = -1[m
     arr[3][2] = (2 * far_clip * near_clip) / (near_clip - far_clip)[m
[32m+[m[32m    #print('projection matrix: ' + str(arr))[m
     return arr[m
 [m
 [m
[36m@@ -27,17 +29,11 @@[m [mdef create_rotation_matrix(x, y, z):[m
                      [z[0], z[1], z[2], 0],[m
                      [0, 0, 0, 1]], dtype='float32')[m
 [m
[31m-[m
 def look_at(position, target, up):[m
[31m-    zaxis = norm_vec3(target - position)[m
[31m-    xaxis = norm_vec3(vertex_math.cross_array(norm_vec3(up), zaxis))[m
[32m+[m[32m    zaxis = vertex_math.norm_vec3(target - position)[m
[32m+[m[32m    xaxis = vertex_math.norm_vec3(vertex_math.cross_array(vertex_math.norm_vec3(up), zaxis))[m
     yaxis = vertex_math.cross_array(zaxis, xaxis)  # quick maths[m
     rotation = create_rotation_matrix(xaxis, yaxis, zaxis)[m
     translation = create_translation_matrix(position * -1)[m
     #rotation[3] = [-np.dot(xaxis, position), -np.dot(zaxis, position), -np.dot(yaxis, position), 1][m
     return translation * rotation[m
[31m-[m
[31m-[m
[31m-def norm_vec3(vec):[m
[31m-    mag = np.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2])[m
[31m-    return np.array([vec[0] / mag, vec[1] / mag, vec[2] / mag])[m
[1mdiff --git a/shaders.py b/shaders.py[m
[1mindex 6904f06..2184ab0 100644[m
[1m--- a/shaders.py[m
[1m+++ b/shaders.py[m
[36m@@ -31,7 +31,13 @@[m [mvarying vec3 fnormal;[m
 varying vec3 fcolor;[m
 void main()[m
 {[m
[31m-    outputColor = vec4(fcolor.x, fcolor.y, fcolor.z, 1.);[m
[32m+[m[32m    vec3 ray = vec3(1., 0., 0.);[m
[32m+[m[32m    vec3 light_dir = -normalize(vec3(1., 1., 1.));[m
[32m+[m[32m    float diffuse = max(dot(fnormal, light_dir), 0.);[m
[32m+[m[32m    float specular = pow(dot(reflect(fnormal, ray), light_dir), 4.);[m
[32m+[m[32m    float ambient = 0.1;[m
[32m+[m[32m    vec3 col = vec3(1.) * (ambient + diffuse * 0.3 + specular * 0.);[m
[32m+[m[32m    outputColor = vec4(fcolor, 1.);[m
 }[m
 """[m
 [m
[1mdiff --git a/vertex_math.py b/vertex_math.py[m
[1mindex c74bfaf..2871c1b 100644[m
[1m--- a/vertex_math.py[m
[1m+++ b/vertex_math.py[m
[36m@@ -1,4 +1,4 @@[m
[31m-import numpy[m
[32m+[m[32mimport numpy, random[m
 [m
 [m
 def get_normals(vertex_data):  # binary vertex data, 3 groups of 3 float 32s represent a triangle[m
[36m@@ -21,8 +21,8 @@[m [mdef get_normals(vertex_data):  # binary vertex data, 3 groups of 3 float 32s rep[m
         x, y, z = v[6], v[7], v[8]  # C[m
         bc = (i - x, j - y, k - z)[m
         ac = (a - x, a - y, a - z)[m
[31m-        norm = cross(*(bc + ac))[m
[31m-        normals += norm[0] + norm[1] + norm[2][m
[32m+[m[32m        norm = norm_vec3(cross(*(bc + ac)))[m
[32m+[m[32m        normals = numpy.append(normals, norm)[m
     return normals[m
 [m
 [m
[36m@@ -37,3 +37,27 @@[m [mdef cross(a, b, c, x, y, z):[m
 [m
 def cross_array(v1, v2):[m
     return cross(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2])[m
[32m+[m
[32m+[m[32mdef norm_vec3(vec):[m
[32m+[m[32m    mag = numpy.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2])[m
[32m+[m[32m    return numpy.array([vec[0] / mag, vec[1] / mag, vec[2] / mag], dtype='float32')[m
[32m+[m
[32m+[m
[32m+[m[32mdef create_cube ():[m
[32m+[m[32m    verts = [[m
[32m+[m[32m        [-1, 1, -1],[m
[32m+[m[32m        [1, 1, -1],[m
[32m+[m[32m        [][m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32mdef random_vertex(box_size):[m
[32m+[m[32m    return numpy.array([[m
[32m+[m[32m        random.random() * box_size - box_size / 2,[m
[32m+[m[32m        random.random() * box_size - box_size / 2,[m
[32m+[m[32m        random.random() * box_size - box_size / 2[m
[32m+[m[32m    ])[m
[32m+[m[32mdef random_triangle(box_size):[m
[32m+[m[32m    return numpy.append(numpy.append([m
[32m+[m[32m        random_vertex(box_size),[m
[32m+[m[32m        random_vertex(box_size)[m
[32m+[m[32m    ), random_vertex(box_size))[m
